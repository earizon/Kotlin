## Apropos:
  Content is versioned in git.  commits, issues and pull-requests welcome!

# External Links
* <https://kotlinlang.org/docs/reference/>
* <https://www.kotlindevelopment.com/>
* <https://kotlinlang.org/docs/resources.html>

# KOTLIN 101  [[{101]] <!-- { 101 -->

* Basic syntax [[{101}]]
  ```
  | import bar.Bar as bBar   <- Imports are similar to Python
  |
  | val max = if (a < b) {   <- EVERYTHING IS AN EXPRESION
  |   print("a Wins "); a       "if" are expresions and the last expression
  | } else if (b > a) {          is the value of the if-block. ( a || b || "throw" )
  |   print("b Wins "); b
  | } else {
  |   print("draw");
  |   throw RuntimeException("") <- Interrupt computation. No solution exists
  | }
  |
  | val a: Int  = 1    // <·· (VAL)UES ARE INMUTABLE. a +=1 will NOT compile  [[{qa.101,qa.immutability]]
  | //     └─┴─················ Optional. Types can be inferred.
  | //                          NOTE: Anything not part of the state-machine is
  | //                                a value. Prefer it over variables.        [[}]]
  |
  | var count  = 5;    // <··  User var(iable) for mutable (var)iables.
  |     count += 1;    // <··  Alowed
  |
  | val (x, y) = funN(count) // <··  splited returned value
  |
  | val s: String? = if (Math.random() < 0.5) // <··· ? => Nullable var (prefer Future to this)
  |                     "Yay!"                //      Non-Nullable by default
  |                  else null
  |
  | println("length of s: ${s.length()}") // formated string with "embedded" expressions.
  |
  | if (obj  is String) ...  // <·· 'is': used for Runtime type-check
  | if (obj !is String) ...
  |
  | val a = Class(param1),   // <·· '==' vs '==='
  |     b = Class(param1)    //
  | a === b                  //     <·· false. a, b are different instances in memory.
  | a ==  b                  //     <·· true . (a.equals(b) returns true)
  |
  | val result =             // <·· try/catch is also an expresion  [[{qa.error_management]]
  | try { count()            //     result will be initialized to inmutable count() or throw
  | } catch (e: ArithmeticException) {
  |   throw RuntimeException(e)
  | }                        //                                     [[}]]
  |
  | l1@ for (i in 1..10) {   // <·· any expresion can be marked with a label
  |   for (j in 1..100) {
  |     if (j == 6) break    //     <·· break will jumps after inner for (default behaviour)
  |     if (j == 5) break@l1 //     <·· break will jumps right after the l1
  |   }
  | }
  |
  | obj: Any = 1
  | String = when(obj) {    // <·· when: extended switch-case
  |   1            -> "One"
  |   "Hello"      -> "Greeting"
  |   is Long      -> "Long"
  |   in 32..128   -> "Is ASCII"
  |   !is String   -> "Not a string"
  |   "dog" in obj -> "Animal list"
  |   else         -> "Unknown"
  | }
  ```

* Strings 101 [[{101.strings}]]
  ```
  | val s1 = "Hello World  $A !"       // <·· String template
  | "col1:  ${ s1.replace("A", "B") } $d"
  | //      └┴──────────────────────┴─    <·· String Expresions
  |
  | val myMultiLineString = """        // <·· Multiline string with margin
  |    |  for (c in "foo")
  |    |      print(c)
  |    |  Dolar is writen as ${'$'}
  | """. trimMargin()                  // <·· remove leading spaces.
  |
  | val s1 = charArrayOf('a','b')      // <·· array to string.
  |          .asSequence()
  |          .joinToString(",")
  ```

* KILLING THE NULL  [[{qa.billion_dolar_mistake,101]]
  * <https://kotlinlang.org/docs/reference/null-safety.html>
  * ```
  | [[{qa.billion_dolar_mistake,101}]]
  |  val nullable01 : String? = "abc"     // <·· nullables must be declared explicetelly with <Type>?
  |
  |  val s02 : String =                   // <·· Assigning nullable to non-nullable
  |     if (nullable01 != null)           // <··    requires if (..!=null) ... else ...
  |         b.length
  |     else -1
  |  val l = b?.length ?: -1              // <·· "Shortcut" / Syntax-sugar Using "Elvis operator" ?:
  |
  |  val name = node.getName()!!          // <·· Abort and throw NullPointerException if null present
  |
  |
  |  nullableInstance ?                   // <·· Null check "shortcut"/"Syntax sugar".
  |     .department ?                     // <··    Returns null if nullableInstance, department
  |        .data ?                        // <··     or data is null
  |
  |  val listWithNulls:
  |     List<String?> = listOf("A", null)
  |  for (item in listWithNulls) {
  |    item ?.let  { println(it) }        // <·· "?.let" skips block if item instance is null
  |       block execution for nulls */*
  |  }
  |
  |  val intList: List<Int> =
  |    listOf(1, 2, null, 4)
  |     .filterNotNull()                  // <·· Fix/Remove Nulls at list initialization.
  |
  |  fun getName(): String? = ...         // <·· SmartCast
  |  val name = getName()                 //
  |  if (name != null) {                  //
  |    println(name.length)               //     Here compiler knows that 'name' is not null
  |  }
  ```

## MICRO-SHELL, REPL : (R)ead, (e)valuate, (p)arse, (L)oop

  ```
  | // REPL example, REF: <https://discuss.kotlinlang.org/t/k2jvmcompiler/3629>
  | private val
  |    REGEX_SEPARATED_TOKENS = Regex("[ \t]+") // [[{101.REPL}]]
  |                                             //
  | private fun parseLine (shellInput : String) //
  | : List<String> =  // returns tokens in line //
  |     shellInput                              //
  |     .split(REGEX_SEPARATED_TOKENS)          //
  |     .filter { !it.isEmpty()}                //
  |                                             //
  | private val USSAGE = """                    //
  |   USSAGE EXAMPLES: ...""".trimMargin()      //
  |                                             //
  | fun main(args: Array<String>) {             //
  |   while (true) {                            //  │<······· 'L' in REPL
  |                                             //            (loop start over next order/command/instruction)
  |     print("PROMPT> ")                       //  ┐
  |     val lineTokens =                        //  │ <······ 'R' in  REPL
  |        parseLine(readLine() ?: continue)    //  │ <······ (readLine will block "waiting" for new input)
  |     if (lineTokens.size == 0) continue      //  ┘
  |     val action = lineTokens[0]              //
  |     if ( action == "quit") break            //  │ <······ 'P' in REPL
  |     val args : List<String> =               //  │
  |       if (lineTokens.size == 0) listOf()    //  │
  |       else                                  //  │
  |       lineTokens.subList(1,lineTokens.size) //  ┘
  |                                             //
  |     val ouput : String = if (false) ""      //  ┐ <······ 'E' in REPL
  |       else if                               //  │
  |         (action == "cmdA") _ExecCmdA(args)  //  │
  |       else if                               //  │
  |         (action == "cmdB") _ExecCmdB(args)  //  │
  |       else USSAGE                           //  ┘
  |     System.err.println(ouput)               //
  |   }                                         //  │<······· 'L' in REPL
  | }                                           //            (loop end  over next order/command/instruction)
  |
  ```

# STANDARD FUNCTIONS [[{std_fun]]
* (no import required)
## apply

  ```
  | val task = Runnable { ... }
  | Thread(task)
  |   .apply  { setDaemon(true) } // <- helper function to init objects,
  |   .apply { ... }              //    1) applies lambda to object
  |   .start()                    //    2) return same object.
  ```

## with(instance)

  ```
  | class Turtle {
  |   turn   (degrees: Double) { ... }
  |   forward(pixels : Double) { ... }
  |   ...
  | }
  | val myTurtle = Turtle()
  | with(myTurtle) {           // <·· Avoid repeated myTurtle. (prefix) typing.
  |   for(i in 1..4) {         //     <·· 1..4 creates 1,2,3,4 range.
  |     forward(100.0);        //
  |     turn(90.0)             //
  |   }                        //
  | }                          //
  ```

## run extension fun

  ```
  | val outputPath = Paths.get("/home/user")
  | .run {                          //  <- A closure {...} is passed to run
  |   val path = resolve("out.log") // ┌·· 'outputPath.' implicit.
  |   //        ^······················┘   path == File("/home/user/out.log)
  |   path.toFile().createNewFile()
  |   path                              <- return value of closure is used as
  | }                                      return value of run itself
  | [[std_fun}]]
  ```

## 'lazy' [[{performance]]
  ```
  | val s1 = lazy {             //  <·· wraps expensive operation to be
  |    expensiveOperationFun()  //      invoked when first required.
  | }
  ```
[[}]]

## 'use' (try-with-resources in java)
  ```
  | val stream = Files.newInputStream( // [[{qa.101}]]
  |     Paths.get("/some/file.txt"))
  | stream.buffered().
  |   reader() .use  {               <- Close reader after { ...} executions
  |   reader ->
  |     println(reader.readText())
  | }
  ```

## repeat (skip "for" loop)
  ```
  | repeat(10, { println("Hello") })
  ```

# KOTLIN DATA STRUCTURES [[{data_structures]] [[ $ TODO: move to correct place ]]

## BASIC TYPES [[{data_structures.standard_types]]

  ```
  | * Long/Int/Short/Byte(64,32,16,8)  <- Numerical.
  | * val c: Char = '\uFF00',          <- Chars
  |       a = 'a',
  |       w = '\b'
  | * Strings
  | * Arrays
  | * Boolean
  |
  |     ┌───────────┬─· alt syntax: '0'..'9'.contains(c)
  | if (c in '0'..'9')               • e.g. explicit Chart to Int conversion
  |   c.toInt() - '0'.toInt()
  | else
  |   throw RuntimeException("...")
  |
  | val x = (1 shl 2) and 0x00FF      • BITWISE OPERATIONS
  | (u)shl/(u)shr) bits:              <- (un)signed shift left/righ
  | and/or/xor                        <- bitwise
  | inv()                             <- bitwise inversion
  |
  | * (Byte|Short|Int|...)Array       • SPECIAL OPTIMIZED ARRAYS [[{performance}]]
  |             [[data_structures.standard_types}]]
  ```

##  Sequence<T> ("Java streams") [[{data_structures.sequences]]
* REF: <https://kotlinlang.org/docs/reference/sequences.html>
* Similar to Java streams or **Unix pipelines**.
* """ Sort of collections of unknown size """        [[{doc_has.KEY-POINT]]
* Compared to collections, sequences do NOT        [[{doc_has.comparative,performance]]
  use/waste intermediate memory during processing. [[}]]
* They can also be seen as "future" collections
  with "future" (unknown at compile time) external
  (incomming or computed) data.
  This is the most common scenarios in production
  environments.                                   [[doc_has.KEY-POINT}]]
  ```
  | var count = 10
  | val sequence = generateSequence {  <- Sequence generator
  |     (count--).takeIf { it > 0 }
  | }
  |                                    ● Generators (Kotlin v.1.2.41+) [[{performance.generators]]
  | val fibonacciSeq = buildSequence {  <- Build generator (vs sequence).
  |     var a = 0, b = 1                   data is generated on-demand (lazely)
  |     yield(1)                           <- 'yield' stops execution until "next-value" request
  |     while (true) {                          ·     to "function" is done.
  |         yield(a + b)                   <-···┘     • See also buildIterator():
  |         val tmp = a + b                     ·
  |         a = b                               ·
  |         b = tmp                             ·
  |     }                                       ·
  |     yieldAll(1..10)                    <···─┴─ yield a collection (or sequence) of values
  | }                                              at once on 'next-value' request.
  |
  | fibonacciSeq.take(8).toList() <··· Ussage [1, 1, 2, 3, 5, 8, 13, 21]
  |
  | val lazySeq = buildSequence { yield(0) }                           [[performance.generators}]
  ```
* while an iterable executes eagerly returning a full intermediate collection on
  each step (filter, map, ...), a sequence executes lazily when possible:
  actual computing happens only when the result of the whole processing chain
  is requested:
  * an Iterable completes each step for the whole collection and then proceeds to the next step.
  * a Sequence performs all the processing steps one-by-one for every single element. 
* BUTS:  The lazy nature of sequences adds some overhead which may be significant when
  processing smaller collections or doing simpler computations. 
  [[data_structures.sequences}]]

## typealias [[{qa.101,performance]]
* Rename a given type with a new alias.
  The alias is simply replaced by the compiler.
  This means that new types are not created or allocated,
  so we suffer no performance penalty.
  ```
  | typealias Cache      = HashMap<String, Boolean>
  | typealias Address    = String  <- WARN: typealias do NOT increase type safety.
  | typealias FamilyName = String     Q: Can Address can be used as FamilyName? [[{PM.TODO}]]
  ```
[[}]]

# COLLECTIONS     [[{data_structures.collections]]

## Arrays vs List<T>     [[{doc_has.comparative]]

* ```
 |  Arrays vs List<T>
 |           └──△──┘
 |      ┌───────┴───────┬───────────────────┬───···
 |  MutableList<T>   ArrayList<T>        LinkedList<T>
 |  └───△────────┘
 |      └──────────┬───────────────────┬───────···
 |          MutableArrayList<T> MutableLinkedList<T>
 ```
* <hr/>
* `Array<T>`: class with KNOWN IMPLEMENTATION (Java array in JVM).
  * sequential fixed-size memory region storing the items.
  * cannot expand or shrink retaining identity
    (a new copy is needed to resize it).
* `(Mutable)List<T>`: interfaces which different implementations:
  * Memory representation and operations logic are defined in
    concrete implementation. <br/>
    e.g.:  indexing is `O(n) in LinkedList<T>, O(1) in ArrayList<T>,...)`
  * MutableList<T> can be resized with `add`, `remove`.
* <hr/>
* `Array<T>` elements are mutable.
* `List<T>`  is either read-only view of MutableList<T> or immutable.
* <hr/>
* `Array<T>`       is invariant on T (`      Array<Int> is NOT Array<Number>`)
* `MutableList<T>` is invariant on T (`MutableList<Int> is NOT MutableList<Number>`)
* `List<T>pp        is covariant      (List<Int> is List<Number>`)
* In practice:
  ```
    val a: Array<Number> = Array<Int>(0) { 0 } // won't compile
    val l: List<Number> = listOf(1, 2, 3) // OK
* <hr/>
* primitive/Array<String>/enum-class arrays can be used in annotations.
  while Lists (and other collections) can NOT.
* <hr/>
* ARRAYS are OPTIMIZED FOR PRIMITIVES through IntArray, DoubleArray, CharArray, ...
  which are mapped to Java primitive arrays (int[], double[], char[]).
* Lists in general do not have implementations optimized for primitives,
  (NOTE: some non-standard libraries do)

  PREFER LISTS OVER ARRAYS EVERYWHERE EXCEPT FOR PERFORMANCE CRITICAL PARTS. [[{doc_has.KEY-POINT}]]

[[doc_has.comparative}]]

## INITIALIZING ARRAYS
  ```
  | val array1: Array<String> =
  |         arrayOf("asdf","ADF")          <- From known set of values (at compile time)
  | val emptyStrArray = arrayOf<String>()  <- Init. empty array
  |
  | val array2: Array = IntArray(20).apply{fill(-1)}
  ```

## INITIALIZING LISTS
  ```
  | val doubleList: List<Double>=
  |         arrayListOf(84.88, ...)         <- Inmutable by default (Use MutableList otherwise)
  | val nonNulls = listOfNotNull<String>    <- Null safe  [{qa.billion_dolar_mistake}]]
  |                  {null, "a",...}
  | val readWriteList: MutableList<String> =<- MUTABLE list
  |                       mutableListOf(...)   An inmutable view can be declared as:
  |                                            val readView:List<String> = readWriteList
  |
  | val    a  = asList(1, 2, 3)             <- from tuple/array
  | val list1 = asList(-1, 1, /*spread*/, 4)<- from spread array.
  | val list2 = list1.filter{ x -> x > 0 }  <- NEW LIST FROM list1 PASSING A FILTER
  |                         └────────────┴── syntax shortcut: { it > 0 }
  |
  | val squaredArray: Array = Array(5,
  |      { idx -> (idx * idx).toString() }) <- lambda-init
  ```

## WALK-OVER/ITERATE ARRAY/LISTS/SEQUENCES
  ```
  | sequence.forEach  { it*it }         <- Alt 1
  | for (valI in myArrayOrList) ...     <- Alt 2
  | for (idx in arr1.indices) ...       <- Alt 3: idx (index ), arr1[idx] (value@index)
  | for ((id, val) in arr01.withIndex())<- Alt 4: idx + value
  |   { ... "$idx -> $val"  }
  | for ((key, value) in map              ) { println("$key -> $value") }
  ```

## FUNCTIONAL PROGRAMMING
  ```
  | list1
  |   .filter { it.startsWith("a") }
  |   .sortedBy { it }
  |   .parallel()              <·· tells JVM to run the rest   [[{performance.101}]]
  |   .map { it.toUpperCase() }    of the pipeline in multiple
  |   .forEeach( println(it) )     threads.
  ```

## INITIALIZING MAPS
  ```
  | val map1 = mapOf("a" to 1, "b" to 2)
  | val map2 = mapOf(Pair("a", 1), Pair("b", 2))
  | println(map1)                       <- '[1, 2]' (Print values, ignore keys)
  ```

## INITIALIZING SETS
  ```
  | val intSet : Set<Int> = setOf(1, 2, ,..)
  | val hashSet: java.util.HashSet<Book> =
  |     hashSetOf(Book(...), Book(...)
  | val longSet: MutableSet<Long> = mutableSetOf(1, 2, 3)
  ```

[[data_structures.collections}]]

## KOTLIN RANGES [[{data_structures.ranges]]

> Ranges are NOT a real data structure, but mathematical
> closed-intervals with well defined operations.<br/>
> In practice the can be seen as some sort of iterable lists.

  ```
  | val aToZ = "a" .. "z"    <···  ANY COMPARABLE TYPE CAN BE USED
  |                                '..': operator(sintax sugar) for a.rangeTo(z)
  | "c" in aToZ  /* true */
  | val countingDown = 100.downTo(0)
  | val ten20 = 10.rangeTo(20).step(2) // 10..2
  | if (x in 1...y+1) { ... }
  | val range1 = Version(1, 11)..Version(1, 30) <·· PRESETUP: create range for Version class.
  | if (Version(0, 9) in range1) { ... }  <·· 'in' (or !in) : Main operation in ranges
  | for (x in 1..10 step 2) { ... }
  |   (1..10).filter { it % 2 == 0 }      <··· map, filter, ... can be used (Iterable implemented)
  | for (x in 10 downTo 0 step 2) { ... }
  | for (n in (1..4).reversed())  { ... }
  ```
[[data_structures.ranges}]]

## data class (DTO)  [[{data_structures.data_class]]

* automatically generates:
  * getters (and setters for vars),
  * equals(), hashCode(), toString(), copy()
  * component1(),… for all properties
  ```
  | data  class Customer(
  | val name  : String,                   // <·· val: inmutable
  | val email : String,                   // <·· val: inmutable
  | var refNum: Int )                     // <·· var:   mutable
  | {                                     // <·· optional class member functions
  |   override fun toString() : String {
  |     return "(${refNum} : ${name} <${email}>)"
  |   }
  | }
  ```
[[data_structures.data_class}]]

[[data_structures}]]

# QA
## Require/assert/check
  ```                                          [[{qa.error_management]]
  | fun neverEmpty(str: String) {
  |   require(str.length > 0,            // <·· require | assert  | check
  |     { "String should not be empty" })
  |   println(str)
  | }                                          [[}]]
  ```

# Regular Expresions [[{regex]]

REF: <https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/>

* Matching and finding the groups in Kotlin:
  ```
  | val regex01     =  Regex ("[a-zA-Z]+([0-9]+)") <- Create Regex
  | val matchGroups = regex01
  |     .matchEntire("ABcD..")?
  |     .groupValues
  | while (matchGroups.find())
  |     println(matchGroups.group())
  ```
[[}]]

# Kotlin Functions   [[{101.functions]]

REF: <https://kotlinlang.org/docs/reference/functions.html>
  ```
  |        (Int) -> String       <··· function type signature:
  |                                   Input  is Int, Output is String
  |  TypeA.(Int) -> String       <··· function-with-receiver type signature
  |                                   Input  is Int, Output is String
  |                                   - Restriction: It must be called
  |                                     within the "context" of a receiver
  |                                     object TypeA (implicit .this in
  |                                     function body)
  |
  |  val fun1:                   <··· type ((A, B) -> C) and
  |   String.(Int) -> String = ...    type ( A.(B) -> C) are compatible types
  |  val fun2:
  |  (String, Int) -> String = fun1     <- OK: Allowed assignement.
  |
  |  suspend   () -> Unit       <··· 'suspend' (vs fun): set as corutine
  |  suspend A.(B) -> C.        <··· 'suspend' corutine with receiver type
  |
  |  (x: Int, y: Int) -> Point  <··· 'x','y' names for parameters is Optional
  |
  |  ((Int) -> Any)?            <··· '?' sets function-type as nullable.
  |
  |  (Int) -> ((Int) -> Unit)   <··· function-type signature returns function-type
  |
  |  typealias ClickHandler =   <··· Type alias for function signature.
  |     (Button, ClickEvent) -> Unit
  |
  |  { a, b -> a + b }          <··· lambda expression, declares and init anonymous func.
  |
  |  fun(s: String): Int {      <··· anonymous fun., useful when we need to explitely
  |    return s.toIntOrNull() ?: 0   define the return-type.
  |  }
  |
  |  NOTE: 'return' inside lambdas        will return from the enclosing function.
  |        'return' inside anonymous fun. will return from the anonymous function itself.
  |                 Use 'return@enclosingFunction' to replicate lambda behaviour.
  |         fun foo() {
  |           ints.forEach lit@ {            <- Alt 1. lambda function
  |             if (it == 0) return          // returns from foo
  |             if (it == 1) return@lit      // returns from lambda lit@
  |             if (it == 2) return@forEach  // returns from lambda lit@ (implicit label)
  |             print(it)
  |           }
  |           ints.forEach( fun(val: Int) {  <- Alt 2. anonymous function
  |             if (it == 0) return          // local returns from  anonymous funct
  |             print(val)
  |           }
  |         }
  |
  |  funA(x)   is equivalent to funA.invoke(x)   for non receiver function-types.
  |  O.funA(x) is equivalent to funA.invoke(O,x) for     receiver function-types
  |
  |  items.fold(1, { lambda } ) <··· "traling lambda" Kotlin (syntax-sugar) convention:
  |  items.fold(1) { ... }           if last (or only) arg of function is a function-type,
  |                                  the lambda expression passed-as-argument can be
  |                                  placed outside the parentheses in order to allow
  |                                  replacing
  |                                  a ({ b ({ c }) })  by
  |                                  a  { b  { c }  }
  |
  |  fun getPoint(                  <····· Alt 1: Fun. Def, java-like
  |      a: Int,
  |      b: Int  = 1                    <- Default values in functions [[qa.billion_dolar_mistake]]
  |      vararg names: String           <- variable-number-of-args supported (0 or more)
  |     )
  |  : Coordinate {                     <- Return type
  |    return Coordinate(a+b,a-b)
  |  }
  |
  |  fun getPoint(                  <····· Alt 2: Fun. Def. Kotlin shorcut.
  |    Int, Int = 1, vararg: String)       <- param names not required.
  |      = Coordinate(a+b,a-b)             <- return type inferred
  |
  |  val (x, y) = getPoint(1,2)         <- split returned value
  |  getPoint(a = 1, b = 2)             <- Using named parameters supported
  |
  |  fun <T> singletonList(item: T):    <- Generic Functions
  |    List<T> {                           <T> is specified before the fun. name
  |      ...
  |  }
  |
  |  inline fun lock(x1: Class1) :      <- Inline fun. definition.
  |    ReturnClass { ... }
  ```
* 'tailrec` tells compiler that implementation must be   [[{performance,PM.TODO}]]
  tail-recursive. Otherwise compilation must fail.
  Compiler optimises out the recursion!!!
  ```
  | fun findFixPoint(x: Double = 1.0)
  | :Double                                //     recursive call must be last operation.
  |   = if (x == Math.cos(x)) x            //     WARN : doesn't work within try/catch.
  |     else findFixPoint(Math.cos(x))     // <·· only supported in JVM as of 2018??
  ```

* (Class) Extension Functions provide a shorted systax
  for the "friend" class objects (String in this case)
  ```
  | fun String.spaceToCamelCase()
  |     String { ... }
  | "to camelcase".spaceToCamelCase() // <·· OK
  | 23424.spaceToCammelCase()         // <·· Compiler error. Doesn't match expected class.
  ```
* Fun. as value object.
  ```
  | val countChars: String.() -> Unit =  // ¹
  |     { println("${length}") }
  | "ASDF".countChars( )                 // == countChars( "ASDF" )
  | ¹ Type is 'String.() -> Unit'
  |   Value is the executable code defined in {} block
  ```
* Function Receivers:<br/>
  Very similar to extension functions but applies to
  func. literals. (that is, to variables representing functions)
  ```
  |         ┌──┬─························· receiver Object members can be
  |val sum: Int.(other: Int) -> Int = {    accessed with an implicit 'this.'
  | other -> plus(other)                ┌· == this.plus, where 'this' is the
  |}         └──┴─······················┘  receiver.
  |                                        == other -> other.plus(this)
  ```
* INFIX Functions (DSL Utility)
  ```
  | class Account {
  |   var balance = 0.0
  |   infix fun add(amount:Double): // <·· 'infix' fun. declaration
  |         : Unit {
  |      this.balance += amount
  |   }
  | }
  | accountInstance add 100.00      // <·· Infix ussage
  ```
* Operator Overloading: Allowed only for a well defined set of operators
  (vs "anything" in C++)
  ```
  | OPERATOR    FUNCTION NAME
  | ========    =============
  | a + b     : plus      ()
  | a - b     : minus     ()
  | A * b     : times     ()
  | A / b     : div       ()
  | A & b     : mod       ()
  | a..b      : rangeTo   ()
  | +a        : unaryPlus ()
  | -a        : unaryMinus()
  | !a        : not       ()
  | [p1,p2,..]: operator fun get(param1, param2,...)
  | < <=  > >=: compareTo ()
  | ()        : operator func invoke()
  ```
* High Order functions:
  ```
  | fun foo(
  |      name: String,
  |      fun1: (String) -> String)   // <·· receives another fun. as param.
  |      : Unit {
  |   val applied = fun1(name)
  |   println(applied)
  | }
  | foo(name = "hello",
  |     fun1 = { it.reversed() } )   // <·· Ussage
  ```
* Closures
  ```
  | fun students(nameToMatch: String)
  |     : List<Student> {
  |   return loadStudents().filter { // <··  CLOSURE: fun. with access to
  |     it.lastName == nameToMatch                    parent stack
  |   }
  | }
  ```
* Memoization: Avoid repeated long-running calculus/processes.
  ```
  | fun Function1 .memoized()   [[{performance.101}]]
  |   : (String) -> MyClass {
  |   val map = ConcurrentHashMap<String, MyClass>()
  |   return {
  |     a -> map.getOrPut(a) {
  |       this.invoke(a)
  |     }
  |   }
  | }
  ```
[[101.functions}]]

# Kotlin OOP [[{oop]]

* Kotlin Classes:
  * REF: <https://kotlinlang.org/docs/reference/classes.html>
  * `Any`: common superclass in Kotlin.
  * It is NOT java.lang.Object;
    it does not have any members other than
    equals(), hashCode() and toString().
  * By default classses are final.  [[{qa.101,qa.immutability}]]<br/>
    Use syntax 'open class ...' to make them non-final

* Kotlin Interfaces [[{101.interfaces]]
  ```
  | interface Iface1<out T : Any> {  // <·· INTERFACE DEFINITION
  |     val prop1: Int                      <· Properties can be part of the interface.
  |     val prop2: String
  |          get() = "foo"                  <· Default accessor
  |     fun bar(): T
  |     fun foo(): Unit
  |     fun foo(a: Int): T                  <· instance: => instance <··> type
  | }
  |
  | class Class : Iface1, Iface2 {  // <·· Declare class implemeting interface
  |   override val prop: Int = 29
  | }
  ```
  * Single-Method Interface Shortcut
    * shortcut/Syntax sugar when an instance
      implements an interface with a single method.
    * (Similar to that used in GO and other modern languages)
    * Applies to common single-method interfaces like
      Runnable, Callable, Closeable, Comparator, ...
    * Example:
      ```
      | val threadPool = Executors.newFixedThreadPool(4)
      |
      | threadPool.submit {   // <·· Shortcut for:
      |   println("...")      //     threadPool.submit(
      | }                     //       object : Runnable {
      |                       //        override fun run() {
      |                       //          println("...")
      |                       //        }
      |                       //       }
      |                       //     )
      ```
      `threadPool.submit(...)` expects a <<Runnable>> instance.
      The compiler infers the "missing code".
  [[101.interfaces}]]

## Composition over Inheritance [[{oop.composition,qa.best_patterns,doc_has.key-point]]

* Composition is sometimes called delegation, where **delegation is actually
the dessign pattern and composition the standard/easiest way to implement it**.
* Inheritance means that child *IS A* parent. This claim fails to be true
  frequently in business applications. Problems that can arise. E.g:
  * Initially a 'worker' can be a physical/legal person and so we claim
    that worker 'IS A' person.  Two years later a 'worker' is a robot, and
    our initial hierchy breaks forcing lot of refactoring (or "patching" our
    initial model considering that robots are persons with "empty name", ...)
  * It's much worse when we want to upgrade the base clase with behaviour that
    children classes were not expected to implement. Eg.:
    * Now a legal person is being used by the legal department and they
      require a physical address for persons, but 'workers' were used by a
      Resource/Scheduling Planning application with no need for this physical address
      and now is receiving extra information that the software does not understand
      or breaks serialization/JSON parsing/...
  * It's much better to have a legal person composed of a legal object, an
    optional worker object, and optional robot object, .... <br/>
    When appropiate, the legal person delegates to the legal object, worker
    object, robot object, ... on demand.
  * ```
    |  INHERITANCE          COMPOSITION
    | (discouraged)        (best pattern)
    | -------------        ----------------
    |  legal person        legal person
    |       ^              - has a ··> legal document
    |       |              - has a ··> ...
    |    ( is a )          - has an optional ··> worker
    |     worker           - has an optional ··> robot
    |                      - has an optional ··> ...
    ```
  * REFs:
    * "Efective Java", By Joshua Bloch, ISBN-13 978-0134685991
    * <https://kotlinlang.org/docs/reference/delegation.html>
  * Note: foreign keys in SQL is the best well known form of composition:
    ```
    employee      person     client       <·· employee and client just keep
    --------      -------    ------           pointers (foreign keys) to
    id      ←─┐┌─→ id   ←─┐  id               persons.
    roll      ││   name   └─ fk_person
    fk_person ─┘   ...    ┌─ fk_saleManager
    ...       └───────────┘   ...
    ```
    When using composition a worker is not a person but is composed with a person.
    * worker01.person is defined.
    * robot_01.person is null or event better, points to mock 'person'.
    * person data can be loaded lazely, on demand, increasing performance.
    * If parent Person add a physical address, Worker is not aware of it,
      it just keep a pointer.
  * Example Composition Implementation in Kotlin:
    ```
    | interface IEmployee { fun doWork() ... }
    | interface IRobot    { fun doMoreWork() ... }
    |
    | class Employee(val resources: Int, ... )
    |    : IEmployee {         // <··
    |   override fun doWork() { ... }
    | }
    |
    | class Person(
    |     val name: String,
    |     val emp : IEmployee?, ¹
    |     ...
    |     )
    |     : IEmployee by emp,  // <·· **Kotlin syntax sugar**: <<IEmployee>>
    |                          //     implementation delegated to .emp member
    |
    | fun main(args: Array<String>) {
    |   val employee01 = Employee( resources: 23, ... )
    |   val   person01 = Person(name: "...", emp: employee01, .. )
    |   person01.doWork()      // <·· translates to:
    |                          //     person01.emp.doWork() ²
    |
    | }
    |
    | ¹ In a future we replace a emp by a Robot instance.
    |   person01.doMoreWork() will compile and execute.
    |   Employee implementation does not need any refactor.
    ```
[[oop.composition}]]

## OOP Inheritance  [[{oop.inheritance]]

* discouraged pattern except when we can formally probe (after
  publishing in a Journal-of-Mathematic paper) that child class
  IS ACTUALLY a base class.
  * `group`, `monoid`, `ring` are always a `set` BY DEFINITION.
  * `triangle`, `square`, .. are always a `closed 2D shape`.
    (but a physical triangle will soon stop being a 2D shape,
     even if some 2D closed shape still apply. In that case use
     delegation through composition).

  ```
  | class Derived(p: Int)         // <·· Inheritance declaration
  |    :  Base(p)
  |
  | class Container(
  |   id     : Int,
  |   size   : Int,
  |   childs : Containers
  | ) : SuperClass(id, name),     // <·· Child class inheriting from SuperClass
  |   Iface1, Iface2, Iface3 {    //     and implementing orthogonal (Unrelated)
  |   var person_id = id          //     interfaces.
  |   val isEmpty: Boolean
  |     get() = this.size == 0 || // <·· Custom (get) accesor.
  |     ( var sum = 0;
  |       for (c in childs) sum+=c.size) == 0
  |   val stringRepr : String
  |      get() = this.toString()
  |      set(value) = _setFromString(value)
  |   // ...
  |
  |   companion object Factory     // <·· companion "singleton" object
  |   : FactoryTemplate<MyClass> { //     object name ('Factory') can be ommited
  |     override fun create():     //     <·· Can be called as static method on Container
  |          Container = Container(...)
  |   }
  |   val instance = Container.create() // [[{PM.TODO}]]
  | }
  ```
[[oop.inheritance}]]

## SINGLETON OBJECTS  [[{oop.singleton,qa.101]]

  ```
  | object  Resource {         <- use 'object' instead of 'class'
  |   val name = "Name"
  |   fun method1(...) { ... }
  |   ...
  | }
  | Resource.method1(...)   [[oop.singleton}]]
  ```

## COMPANION OJECTS (Java "static" methods)
  ```
  | class Class1 {
  |   companion object Fact01      <·· Companion object. 'Fact01' name can be omitted *1
  |      : IFactory<Class1> {      <·· the companion object can (at will) implement an interface
  |                                    (this is not possible with static methods in Java)
  |     override fun create(): ...     Use @JvmStatic annotation for compatibility with Java
  |   }                                *1: It can still be referenced with Class1.Companion
  | }
  | val instance = Class1.create() <·· In can be now used as an "static" method.
  ```

## COMPAQ CLASS DECLARATION [[{]]
  ```
  | class Person(
  |   val firstName: String,   <- val/var in constructor define also members
  |   val lastName: String,
  |   var age: Int) {
  |   ...
  | }
  |
  | class Customer
  |   public
  |   @Inject
  |   constructor ( val name: String = "")  <- 'constructor'  keyword optional if no
  | {                                          annotations and default visibility applies
  |     ...
  |     init {                              <- 'init' marks an initializer block
  |       logger.info("init ${name}")
  |     }
  |     constructor(parent: Person) {       <-  "Secondary" constructor
  |       parent.children.add(this)
  |   }
  | }
  ```
[[}]]

## SEALED CLASS
* REF: <https://kotlinlang.org/docs/reference/sealed-classes.html>    [[{oop.sealed_class]]
* represent restricted class hierarchies or "sort of" enum extensions,
  with subclasses being able to have multiple instances.
* (sealed class/subclasses must be declared in the same file)
  ```
  | sealed class Expr         <························ 'sealed' declares 'Expr' as sealed.
  | data class Const(val number: Double)       : Expr()
  | data class Sum(val e1: Expr, val e2: Expr) : Expr()
  | object /*singleton*/ NotANumber            : Expr()

  | fun eval(expr:  Expr ): Double =                   <··· Ussage:
  |   when(expr) {
  |   is  Const       -> expr.number
  |   is  Sum         -> eval(expr.e1) + eval(expr.e2)
  |       NotANumber  -> Double.NaN
  | }
  ```
  [[oop.sealed_class}]]

  ```
  // INNER CLASS                       [[{oop.inner_class]]
  window.addMouseListener(
    object : ListenerBase (         <·· Ex.1: Object expressions are a
    baseClassConstructorParam1,         generalization of anonymous
    ...) {                              inner classes.
      override fun
        onMouseClicked(e: MouseEvent)
          { ... }
    })

  interface B {...}                 <· Ex.2: [[{PM.TODO}]]
  val ab: A = object : A(1),
              B { override ...  }      [[oop.inner_class}]]
  ```
[[oop}]]

# `atomic` concurrent code [[{performance.101,concurrent.101]]
* STM: Software transactional memory
* Extracted from <https://blog.plan99.net/kotlin-fp-3bf63a17d64a>
  """ JVM can support libraries like Scala STM and something better:
  ...Modern (very modern as of 2015) Intel chips support 'TSX'
  instructions to create an hardware atomic TX, controlling cache
  lines accessed by different cores simultaneously.<br/>
   In case of conflict, the CPU aborts the TX and expects the code to
  try again or fall back to regular locking.<br/>
    Java 8 Update 40, the "RTM locking" is enabled by default when the
  CPU supports it converting every Java synchronized block into a
  hardware level atomic transaction using TSX.<br/>
  NOTE: STMs often provide extra features, like the ability to
  pause/retry a code block when the dependencies change, or the
  ability to explicitly cancel a TX (by throwing) without retrying it.
* Example
  ```
  | val accounts = intArrayOf(10,..) <··· our critical structure
  | try {
  |   atomic {  // ¹
  |     accounts[from] -= amount
  |     accounts[to] += amount
  |     if (...) throw ...
  |   }
  | } catch(e: Exception) {
  |     println("counter is ${counter.get()}")        // -> 10
  | }
  |
  | ¹: higher order function protected by Java 'synchronized',
  |    immediately calling the provided code block. The JVM will
  |    ignore the lock on TSX-enabled hardware with all threads
  |    running in parallel.
  |    As long as two threads are using different account IDs
  |    for 'from'/'to' no locking is done at all.
  ```
* Things Kotlin lacks (As of 2015)
  * no way to control side effects for non const (val) variables.
    or external inputs/outputs.
  * lack of a high performance immutable collections library.
    Both Clojure and Scala have maps and sets in which mutating the
    collection returns a new collection, with internal data sharing
    to make performance practical.
[[concurrent.101}]]
[[101}]]
<!-- 101 } -->

## Kotlin declaration-site variance [[{generics]]
* Refer to <https://kotlinlang.org/docs/generics.html> for full details.
  ```
  | interface                         Source is covariant in O, contravariant in I.
  | Source<out O, in I> {         <·· O is only returned (produced), never take as input param.
  |                                   I is only taken as input (consumed) param, never returned.
  |   fun nextT(): O              <·· out O may occur only in the out-position in the members of C
  |   fun compareTo(other: T): Int<·· in  I may occur only in input-position params.
  | }
  |
  | class
  | Array<T>(val size: Int) {     <·· T now is an in and out. neither co/contra-variant
  |   operator fun
  |   get(index: Int): T { ... }
  |
  |   operator fun
  |   set(index: Int, value: T) { ... }
  | }
  |
  | fun
  | copy(from: Array<Any>, to: Array<Any>)     <·· Compilation error.
  | fun
  | copy(from: Array<out Any>, to: Array<Any>) <·· OK, this is called "TYPE PROJECTION"
  |
  | Type projection: "It is not a simple array, but is rather a restricted (projected) one"
  |
  | Foo<out T : TUpper>                        <·· T is covariant type "up to" TUpper
  | fun
  | <T : Comparable<T>> sort(list: List<T>)
  | {  ... }
  |
  | if (something is List<*>)                  <·· '*' needed to check for types.
  ```
[[generics}]]



# Kotlin Domain Specific Language (DSL) [[{101.dsl]]
* REFs:
  <https://blog.jetbrains.com/kotlin/2011/10/dsls-in-kotlin-part-1-whats-in-the-toolbox-builders/>
  <https://kotlinlang.org/docs/reference/type-safe-builders.html>j
* Examples
  * [Programatically generate layouts](https://github.com/Kotlin/anko/wiki/Anko-Layouts)
  * [Defining REST-API routing trees](https://ktor.io/features/routing.html#routing-tree)

* java vs Kotlin DSL
  ```
  | JAVA-LIKE Code                        Kotlin DSL  equivatent
  | Collection.sort( list );               list .sort();
  | int index = Collection                 int index = list .binarySearch(x);
  |             .binarySearch( list ,x);   └─────┬─────────────────────────┘
  | ┌············································┘
  | PRESETUP:
  |
  | fun <T : Comparable<T>>  List<T>. sort() {  <··· Restrict fun <T : Comparable<T>> sort()
  |    Collections.sort(this)                        to List<T> elements
  | }                                                (i.e., only to elements compatibles with
  |                                                   Collections.sort )
  ```

  ```
  | JAVA-LIKE Code:               | DSL using infix functions
  | ---------------------------   | ------------------------        human friendly "subject"
  | hasPrivilege (  it , WRITE)   | it   hasPrivilege  WRITE  <···  + verb + "predicate"
  |
  |                               |                                 last function literal can be
  | lock(myLock,   {...} )        | lock(myLock),   {...}     <···  put outside the parenthesis
  |
  |                               |                                 Convention:
  |                               |                                 If function has a single input param,
  |                               |                                 its declaration may be omitted,
  | filter { it => it.foo()}      |filter { it.foo() }        <···  default "it" name used.
  ```
* Example Kotlin DSL for Type-safe HTML builder:
  * For more elaborate example code check:
    <https://kotlinlang.org/docs/type-safe-builders.html> and
    <https://github.com/Kotlin/kotlinx.html>
  ```
  | Code Summary -----------------
  | class HTML {               //  <··· STEP 1: Receiver class
  |     fun body() ...
  | }
  |
  | fun funHtml(                   <·· STEP 2: funHtml builder with input:
  |   initLambda:  HTML.()->Unit       any arbitrary lamda matching the
  | )  //          └───────────┴─····· function-with-receiver signature declaration
  | : HTML {
  |   val html = HTML()         // <·· create the receiver object
  |   html.initLambda()         // <··  pass the receiver object to the lambda
  |   return html
  | }
  |
  | funHtml                     // <·· STEP 3: Use it by invoking the 'builder
  | {                                  with an arbitrary lambda function compatible
  |     body()       == this.body(     with the signature.
  | }
  ```
[[101.dsl}]]

# kotlinx.serialization: marshal objects using JSON or ProtoBuf. [[{IO.serialization,JSON,]]
* REF: <https://github.com/kotlin/kotlinx.serialization>

  ```
  | import kotlinx.serialization.*
  | import kotlinx.serialization.json.*
  |
  | @Serializable
  | data class DProject(val name: String, val language: String)
  |
  | val data1  = DProject("kotlinx", "Kotlin")
  | val strn1 = Json.encodeToString(data)  //  <·· Object  to  JSON-string
  | val data2 = Json                       //  <·· Object from JSON-string
  |             .decodeFromString<DProject>(strn1)
  ```
[[}]]

# 'gradle.properties' customization:  [[{devops.gradle]]

REF: <https://kotlinlang.org/docs/reference/using-gradle.html>

  ```
  | kotlin.code.style=official
  | kotlin.caching.enabled=true
  | kotlin.incremental=true
  | kotlin.incremental.js=true
  |
  | kapt.use.worker.api=true   <·· REF:
  | kapt.incremental.apt=true      <https://kotlinlang.org/docs/reference/kapt.html>
  ```
[[devops.gradle}]]

# Coroutines  [[{coroutines,doc_has.comparative,performance]]
* experimental starting with v.1.1+
* Basically, coroutines are computations that can be suspended
  without blocking a thread.
* Suspension can be controlled by a user library to a large extent
  deciding what happens upon suspension and optimize/log/intercept
  according to our needs.
* Compared to threads, coroutines can not be suspended at random
  instructions, but rather only at defined suspension points, which are
  calls to specially marked functions.
  ```
  suspend fun  susA(foo: Foo)    <·· 'suspend' marks the function as a suspension point
               : Bar {               funA can ONLY be called from coroutines and other
    ...                              suspending functions
  }
  ```
* To start a coroutine, there must be at least one suspending function,
  and it is usually a suspending lambda. Ex:
  ```
  |           ┌·····················  async is a regular function
  |           │                    ┌ lambda suspendable funct
  |         ┌─┴─┐             ┌────┴───────┐
  | fun <T> async(  block :  suspend () -> T)
  ```
* Suspendable functions USSAGE rules:
  * suspending functions can **NOT** be called from function literals that
    are NOT inlined into a suspending function body and from regular
    function like main():
  * ```
    | fun main(args: Array<String>) {
    |   susA()              // <·· KO: Can NOT be called
    |                       //         from non-coroutine context
    |   async {
    |     susA(foo)         // <·· OK: inside async fun.
    |     ...
    |     val result =      //     await() can be a suspending function
    |       compute.await() // <·· suspending the coroutine until some
    |                       //     computation is done
    |     ...
    |     computations
    |       .forEach {      // <·· lambda will be inlined.
    |         it.await()    // <·· OK: Async. blocking calls can now
    |     }                        be expressed sequentially
    |   }
    |
    |   async {
    |     thread {
    |       susA()          // <·· KO: `thread` is not an inline fun.
    |     }                 //         so the lambda is not inlined
    |   }
    | }
    |
    | @RestrictsSuspension  // <·· prevent users from adding new ways of
    | public abstract class        suspending a coroutine all suspending
    | SequenceBuilder<in T> {      extensions are required to delegate to
    |     ...                      members of class or class-extensions
    | }                            avoid third extensions to delegate on
    |                              each other indefinitely and forcing all
    |                              suspensions to be controlled by members
    |                              of the class.
    |                              controlled by the author of the library.
   ```


[[{doc_has.KEY-POINT}]]
 The underlying library will transparently hide all the complexity
of wrapping callbacks, subscribing to relevant events, scheduling
execution on different threads (or even different machines!)<br/>
 It can be used to implement async mechanisms like async/await in
C#/ECMAScript, channels/select in Go, generators/yield in C#/Python.

## Inner working:
  Coroutines are completely implemented through a compilation technique
(NO SUPPORT FROM THE VM OR OS SIDE IS REQUIRED), and suspension
through code transformation.


[[{doc_has.KEY-POINT]]
 Briefly put, every suspending function is transformed to a state machine
where states correspond to suspending calls. Right before a suspension,
the next state is stored in a field of a compiler-generated class
along with relevant local variables, etc.<br/>
Upon resumption of that coroutine, local variables are restored and the
state machine proceeds from the state right after suspension.
[[}]]

  A suspended coroutine can be stored and passed around as an object
that keeps its suspended state and locals. The type of such objects is
Continuation, and the overall code transformation described here corresponds to
the classical Continuation-passing style. Consequently, suspending functions
take an extra parameter of type Continuation under the hood.

* See also Design documents and examples for coroutines in Kotlin
  * <https://github.com/Kotlin/kotlin-coroutines>
  * <https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#composing-suspending-functions>

## kotlinx.coroutines [[{PM.TODO]]
* <https://kotlinlang.org/docs/reference/coroutines.html>
* <https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md>

* This repo mostly consists of core primitives and interfaces that all coroutine-based
  libraries are likely to use covering:
  * Platform-agnostic asynchronous programming with kotlinx-coroutines-core,
    including Go-like channels that support select and other convenient
    primitives.
  * APIs based on CompletableFuture from JDK 8: kotlinx-coroutines-jdk8
  * Non-blocking IO (NIO) based on APIs from JDK 7 and higher:
    kotlinx-coroutines-nio
  * Support for Swing (kotlinx-coroutines-swing) and JavaFx
    (kotlinx-coroutines-javafx)
  * Support for RxJava: kotlinx-coroutines-rx [[PM.TODO}]]
[[coroutines}]]

# kscript (Kotlin as script lang)  [[{qa.UX,PM.TODO.now]]
* <https://github.com/holgerbrandl/kscript>
* See also
  <https://holgerbrandl.github.io/kscript_kotlinconf_2017/kscript_kotlinconf.html#1>
* Compiled script caching (using md5 checksums).
* Dependency declarations using gradle-style resource locators and
  automatic dependency resolution with maven
* More options to provide scripts including interpreter mode,
  reading from stdin, local files or URLs
* Embedded configuration for Kotlin runtime options
* Support library to ease the writing of Kotlin scriptlets
* Deploy scripts as stand-alone binaries
[[qa.UX}]]

# TODO NON CLASSIFIED NOTES [[{PM.TODO.non_classified]]
## kotlin.test: (out of the box in Kotlin 1.2+)
* http://kotlinlang.org/api/latest/kotlin.test/index.html
  write test once under JVM and JS.

## https://github.com/kotlin/kotlinx.html
* supports ISOMORPHIC RENDERING, using the same code to
  render HTML in the backend and in the frontend

# https://javalin.io [[{IO.http.javalin,qa.UX,qa.documentation,PM.low_code]]
* Javalin support OpenAPI (including Swagger UI and ReDoc).
* Built on top of Jetty.
* 7k lines of code, 10k lines of tests!!!
* No need to extend classes and rarely need for new interfaces.
* Used by Johns Hopkins Institute, Microsoft, Red Hat, Norwegian 
  University of Science and Techology, Uber, Deutsche Kredibank AG, 
  C6BANK, ...
* Web Sockets supports
* example.kt 
  ```
  | // Deps: implementation "io.javalin:javalin:5.3.1"
  | import io.javalin.Javalin;
  | import io.javalin.apibuilder.ApiBuilder.*;
  |
  | val app = Javalin.create { config ->
  |     config.enableCorsForAllOrigins()
  |     config.asyncRequestTimeout = 10_000L
  |     config.enforceSsl = true
  | }.routes {
  |     path("users") {
  |         get(UserController::getAll)
  |         post(UserController::create)
  |         path("{userId}") {
  |             get(UserController::getOne)
  |             patch(UserController::update)
  |             delete(UserController::delete)
  |         }
  |         ws("events", userController::webSocketEvents)
  |     }
  | }.start(port)
  ```
[[IO.http.javalin}]]

## Kotlin Multiplatform for iOS Developers [[{PM.TODO,iOS]]
REF: <https://www.infoq.com/articles/kotlin-multiplatform-ios-developers/>

* Avoid repeating lot of logic to develop an app running on
  multiple platforms.
* KMP is not the final step to accomplishing 100% shared code across
  all platforms since UI logic must still be programmed natively in
  many cases because it is too platform-specific to share.
* The close similarities between Swift's and Kotlin's syntax greatly
  reduces a massive part of the learning curve involved with writing
  that KMP business logic.
* You can use Android Studio to create a reusable KMP component that
  you later import into an Xcode project as a framework.
[[}]]


## lateinit var
   ```
   | public class MyTest {                   [[{q.billion_dolar_mistake}]]
   |   lateinit var subject: TestSubj // <·· lateinit: non-null property that can NOT be 
   |                                         initialized in constructor but through dependency injection,...)
   |   @SetUp fun setup() {                  We still want to avoid null checks. 
   |       subject = TestSubj()              If the property has not custom getters/setters it can be 
   |   }                                     used as non-null anywhere except in constructor.
   |                                         Accessing it before init. throws an special exception
   |   @Test fun test() {                    that clearly identifies the issue.
   |       subject.method()           // <·· dereference directly
   |   }
   | }
   ```

## Processing Data with Kotlin Dataframe [[{data_structures.dataframe,PM.TODO]]
* <https://www.infoq.com/news/2022/08/kotlin-dataframe-preview/>
[[}]]

[[PM.TODO.non_classified}]]
