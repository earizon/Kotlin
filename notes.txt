● APROPOS:
- Visit next Web site for a great experience:
  https://earizon.github.io/txt_world_domination/viewer.html?payload=../Kotlin/notes.txt

- If you want to contribute to great gistory of this
  document you can take the next flight to:
@[https://www.github.com/earizon/Kotlin]
  Your commits and pull-request will be immortalized
  in the Pantheon of the Unicode Gods.
────────────────────────────────────────────────────────────────────────────────

[[{kotlin]]
● External Links [[{]]
· @[https://kotlinlang.org/docs/reference/]
· @[https://www.kotlindevelopment.com/]
· @[https://kotlinlang.org/docs/resources.html]
[[}]]

KOTLIN 101  [[{101]]
==========                ● EVERYTHING IS AN EXPRESION
  val max = if (a < b) {   <- "if" are expresions and the last
    print("a Wins "); a        expression is the value of the if-block.
  } else if (b > a) {          ( a || b)
    print("b Wins "); b
  } else {
    print("draw");
    throw RuntimeException("") <- Interrupt computation. No solution exists
  }

  val a: Int  = 1      <──● (VAL)UES ARE INMUTABLE. a +=1 will NOT compile  [[{qa.101,qa.immutability]]
       └───┴─················ Optional. Types can be inferred.
                              NOTE: Anything not part of the state-machine is
                                    a value. Prefer it over variables.        [[}]]

  var count  = 5;          <- User var(iable) for mutable (var)iables.
      count += 1;
  val (x, y) = funN(1,2)   <- split returned value

  val s: String? = if (Math.random() < 0.5) <··· Nullable var (prefer Future to this)
                      "Yay!"
                   else null
 Optionality is so common in programs that it makes sense to integrate it at a deep level, for both convenience and performance reasons:
println("length of string is .... ${s.length()}")



  import bar.Bar as bBar   <- Imports are similar to Python

  if (obj  is String) ...  <- 'is' used for Runtime type-check
  if (obj !is String) ...

  val a = Class(param1),   '==' vs '==='
      b = Class(param1)
  a === b                  <- returns false. a,b are different instances in memory.
  a ==  b                  <- returns true. (a.equals(b) returns true)

  val result =                      [[{qa.error_management]]
  try { count()                     <- try/catch is also an expresion (return val)
  } catch (e: ArithmeticException) {
    throw RuntimeException(e)
  }                                 [[}]]

  loop1@ for (i in 1..100) {  <- any expresion can be marked with a label
    for (j in 1..100) {
      if (j == 55) break@loop1    <- jumps right after the loop1
    }
  }



● MICRO-SHELL, REPL : (R)ead, (e)valuate, (p)arse, (L)oop  [[{101.REPL]]
  REF: https://discuss.kotlinlang.org/t/k2jvmcompiler/3629
  ┌ REPL example ───────────────────────────────┐
  │ private val                                 │
  │    REGEX_SEPARATED_TOKENS = Regex("[ \t]+") │
  │                                             │
  │ private fun parseLine (shellInput : String) │
  │ : List<String> =  // returns tokens in line │
  │     shellInput                              │
  │     .split(REGEX_SEPARATED_TOKENS)          │
  │     .filter { !it.isEmpty()}                │
  │                                             │
  │ private val USSAGE = """                    │
  │   USSAGE EXAMPLES: ...""".trimMargin()      │
  │                                             │
  │ fun main(args: Array<String>) {             │
  │   while (true) {                            ││<······· 'L' in REPL
  │                                             │          (loop start over next order/command/instruction)
  │     print("PROMPT> ")                       │┐
  │     val lineTokens =                        ││ <······ 'R' in  REPL
  │        parseLine(readLine() ?: continue)    ││ <······ (readLine will block "waiting" for new input)
  │     if (lineTokens.size == 0) continue      │┘
  │     val action = lineTokens[0]              │
  │     if ( action == "quit") break            ││ <······ 'P' in REPL
  │     val args : List<String> =               ││
  │       if (lineTokens.size == 0) listOf()    ││
  │       else                                  ││
  │       lineTokens.subList(1,lineTokens.size) │┘
  │                                             │
  │     val ouput : String = if (false) ""      │┐ <······ 'E' in REPL
  │       else if                               ││
  │         (action == "cmdA") _ExecCmdA(args)  ││
  │       else if                               ││
  │         (action == "cmdB") _ExecCmdB(args)  ││
  │       else USSAGE                           │┘
  │     System.err.println(ouput)               │
  │   }                                         ││<······· 'L' in REPL
  │ }                                           │          (loop end  over next order/command/instruction)
  └─────────────────────────────────────────────┘        [[101.REPL}]]


● STANDARD FUNCTIONS (no import required) [[{std_fun]]
 ┌─ apply ───────────────────────
  val task = Runnable { ... }
  Thread(task)
  .apply  { setDaemon(true) } <- helper function to init objects,
  .apply { ... }                 1) applies lambda to object
  .start()                       2) return same object.

 ┌─ with(instance)  ──────────────
  class Turtle {
    turn   (degrees: Double) { ... }
    forward(pixels : Double) { ... }
    ...
  }
  val myTurtle = Turtle()
  with(myTurtle) {         <- Avoid repeated myTurtle. (prefix) typing.
    for(i in 1..4) {          <- 1..4 creates 1,2,3,4 range.
      forward(100.0);
      turn(90.0)
    }
  }
 ┌─ run extension fun ────────────
  val outputPath = Paths.get("/home/user")
  .run {                           <- A closure {...} is passed to run
    val path = resolve("out.log") ┌·· 'outputPath.' implicit.
              ^···················┘   path == File("/home/user/out.log)
    path.toFile().createNewFile()
    path                           <- return value of closure is used as
  }                                   return value of run itself
  [[std_fun}]]

 ┌─ 'lazy' [[{performance]] ─────
  val lazyString = lazy {          <- wraps expensive operation to be
     expensiveOperationFun()          invoked when first required.
  }                                   [[}]]

 ┌─ 'use' (try-with-resources in java) [[{qa.101]]
  val stream = Files.newInputStream(
      Paths.get("/some/file.txt"))
  stream.buffered().
    reader() .use  {               <- Close reader after { ...} executions
    reader ->
      println(reader.readText())
  }                                   [[}]]

  repeat(10, { println("Hello") }) ● repeat: Avoid "for" for simple operations

● KOTLIN DATA STRUCTURES [[{data_structures]] [[ $ TODO: move to correct place ]]
  BASIC TYPES [[{data_structures.standard_types]]
  * Long/Int/Short/Byte(64,32,16,8)  <- Numerical.
  * val c: Char = '\uFF00',          <- Chars
        a = 'a',
        w = '\b'
  * Strings
  * Arrays
  * Boolean

      ┌───────────┬─· alt syntax: '0'..'9'.contains(c)
  if (c in '0'..'9')               • e.g. explicit Chart to Int conversion
    c.toInt() - '0'.toInt()
  else
    throw RuntimeException("...")

  val x = (1 shl 2) and 0x00FF      • BITWISE OPERATIONS
  (u)shl/(u)shr) bits:              <- (un)signed shift left/righ
  and/or/xor                        <- bitwise
  inv()                             <- bitwise inversion

  * (Byte|Short|Int|...)Array       • SPECIAL OPTIMIZED ARRAYS [[{performance}]]
              [[data_structures.standard_types}]]

  Sequences (Java streams) [[{data_structures.sequences]]
  """ Sort of collections of unknown size """        [[{02_doc_has.KEY-POINT]]
  - Compared to collections, sequences do NOT        [[{02_doc_has.comparative,performance]]
    use/waste intermediate memory during processing. [[}]]
  - They can also be seen as "future" collections
    with "future" (unknown at compile time) external
    (incomming or computed) data.
    This is the most common scenarios in production
    environments.                                   [[02_doc_has.KEY-POINT}]]
  var count = 10
  val sequence = generateSequence {  <- Sequence generator
      (count--).takeIf { it > 0 }
  }
                                     ● Generators (Kotlin v.1.2.41+) [[{performance.generators]]
  val fibonacciSeq = buildSequence {  <- Build generator (vs sequence).
      var a = 0, b = 1                   data is generated on-demand (lazely)
      yield(1)                           <- 'yield' stops execution until "next-value" request
      while (true) {                          ·     to "function" is done.
          yield(a + b)                   <-···┘     • See also buildIterator():
          val tmp = a + b                     ·
          a = b                               ·
          b = tmp                             ·
      }                                       ·
      yieldAll(1..10)                    <···─┴─ yield a collection (or sequence) of values
  }                                              at once on 'next-value' request.

  fibonacciSeq.take(8).toList() <··· Ussage [1, 1, 2, 3, 5, 8, 13, 21]

  val lazySeq = buildSequence { yield(0) }                           [[performance.generators}]

  [[data_structures.sequences}]]

● typealias: [[{qa,performance]]
- Rename a given type with a new alias.
  The alias is simply replaced by the compiler.
  This means that new types are not created or allocated,
  so we suffer no performance penalty.
  typealias Cache      = HashMap<String, Boolean>
  typealias Address    = String  <- WARN: typealias do NOT increase type safety.
  typealias FamilyName = String     Q: Does it means that Address can be used as FamilyName?
[[}]]

***************
* COLLECTIONS *     [[{data_structures.collections]]
***************
● Arrays vs List<T>     [[{02_doc_has.comparative]]
            └──△──┘
      ┌────────┴───────┬───────────────────┬───···
  MutableList<T>   ArrayList<T>        LinkedList<T>
  └─────△──────┘
        └──────────┬───────────────────┬───────···
            MutableArrayList<T> MutableLinkedList<T>

  - Array<T>: · class with KNOWN IMPLEMENTATION (Java array in JVM).
                sequential fixed-size memory region storing the items.
              · cannot expand or shrink retaining identity
                (a new copy is needed to resize it).

  - (Mutable)List<T>: interfaces which different implementations:
              · Memory representation and operations logic are defined in
              · concrete implementation. e.g.:  indexing is
                O(n) in LinkedList<T>, O(1) in ArrayList<T>,...)

  - MutableList<T> can be resized with 'add', 'remove'.

  - Array<T> is mutable
  - List<T>  is either read-only view of MutableList<T> or immutable.

  - Array<T>       is invariant on T (      Array<Int> is NOT Array<Number>)
    MutableList<T> is invariant on T (MutableList<Int> is NOT MutableList<Number>)
    List<T>        is covariant      (       List<Int> is List<Number>)
    In practice:
    val a: Array<Number> = Array<Int>(0) { 0 } // won't compile
    val l: List<Number> = listOf(1, 2, 3) // OK

    [[{02_doc_has.KEY-POINT]]
    - ARRAYS are OPTIMIZED FOR PRIMITIVES through IntArray, DoubleArray, CharArray, ...
      which are mapped to Java primitive arrays (int[], double[], char[]).
    - Lists in general do not have implementations optimized for primitives,
      (NOTE: some non-standard libraries do)
    - PREFER LISTS OVER ARRAYS EVERYWHERE EXCEPT FOR PERFORMANCE
      CRITICAL PARTS.  [[}]]

  - primitive/Array<String>/enum-class arrays can be used in annotations.
    while Lists (and other collections) can NOT.  [[02_doc_has.comparative}]]

                                        ● INITIALIZING ARRAYS
  val array1: Array<String> =
          arrayOf("asdf","ADF")          <- From known set of values (at compile time)
  val emptyStrArray = arrayOf<String>()  <- Init. empty array

  val array2: Array = IntArray(20).apply{fill(-1)}

                                        ● INITIALIZING LISTS
  val doubleList: List<Double>=
          arrayListOf(84.88, ...)         <- Inmutable by default (Use MutableList otherwise)
  val nonNulls = listOfNotNull<String>    <- Null safe  [{qa.billion_dolar_mistake}]]
                   {null, "a",...}
  val readWriteList: MutableList<String> =<- MUTABLE list
                        mutableListOf(...)   An inmutable view can be declared as:
                                             val readView:List<String> = readWriteList

  val    a  = asList(1, 2, 3)             <- from tuple/array
  val list1 = asList(-1, 1, /*spread*/, 4)<- from spread array.
  val list2 = list1.filter{ x -> x > 0 }  <- NEW LIST FROM list1 PASSING A FILTER
                          └────────────┴── syntax shortcut: { it > 0 }

  val squaredArray: Array = Array(5,
       { idx -> (idx * idx).toString() }) <- lambda-init

                                      ● WALK-OVER/ITERATE ARRAY/LISTS/SEQUENCES
  sequence.forEach  { it*it }         <- Alt 1
  for (valI in myArrayOrList) ...     <- Alt 2
  for (idx in arr1.indices) ...       <- Alt 3: idx (index ), arr1[idx] (value@index)
  for ((id, val) in arr01.withIndex())<- Alt 4: idx + value
    { ... "$idx -> $val"  }
  for ((key, value) in map              ) { println("$key -> $value") }

  list1                               ● FUNCTIONAL PROGRAMMING
    .filter { it.startsWith("a") }
    .sortedBy { it }
    .parallel()              <·· tells JVM to run the rest   [[{performance.101]]
    .map { it.toUpperCase() }    of the pipeline in multiple
    .forEeach( println(it) )     threads.                    [[}]]

                                      ● INITIALIZING MAPS
  val map1 = mapOf("a" to 1, "b" to 2)
  val map2 = mapOf(Pair("a", 1), Pair("b", 2))
  println(map1)                       <- '[1, 2]' (Print values, ignore keys)

                                      ● INITIALIZING SETS
  val intSet : Set<Int> = setOf(1, 2, ,..)
  val hashSet: java.util.HashSet<Book> =
      hashSetOf(Book(...), Book(...)
  val longSet: MutableSet<Long> = mutableSetOf(1, 2, 3)
  [[data_structures.collections}]]

● KOTLIN RANGES: [[{data_structures.ranges]]
  """... Ranges are NOT a real data structure, but
    mathematical closed-intervals with well defined operations.
    In practice the can be seen as some sort of iterable lists. """

  val aToZ = "a" .. "z"    <···  ANY COMPARABLE TYPE CAN BE USED
                                 '..': operator(sintax sugar) for a.rangeTo(z)
  "c" in aToZ  /* true */
  val countingDown = 100.downTo(0)
  val ten20 = 10.rangeTo(20).step(2) // 10..2
  if (x in 1...y+1) { ... }
  val range1 = Version(1, 11)..Version(1, 30) <·· PRESETUP: create range for Version class.
  if (Version(0, 9) in range1) { ... }  <·· 'in' (or !in) : Main operation in ranges
  for (x in 1..10 step 2) { ... }
    (1..10).filter { it % 2 == 0 }      <··· map, filter, ... can be used (Iterable implemented)
  for (x in 10 downTo 0 step 2) { ... }
  for (n in (1..4).reversed())  { ... }
               [[data_structures.ranges}]]

● data class (DTO)  [[{data_structures.data_class]]
  automatically generates:
  - getters (and setters for vars),
  - equals(), hashCode(), toString(), copy()
  - component1(),… for all properties

  data  class Customer(
  val name  : String,                   <··· val: inmutable
  val email : String,                   <··· val: inmutable
  var refNum: Int )                     <··· var:   mutable
  {                                     <··· optional class member functions
    override fun toString() : String {
      return "(${refNum} : ${name} <${email}>)"
    }
  }
[[data_structures.data_class}]]

[[data_structures}]]

                                           ● Require/assert/check [[{qa.error_management]]
  fun neverEmpty(str: String) {
    require(str.length > 0,
      { "String should not be empty" })
    println(str)
  }                                          [[}]]

● Regular Expresions (Regex) [[{regex]]
@[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/-regex/]
  // Matching and finding the groups in Kotlin:

  val regex01     =  Regex ("[a-zA-Z]+([0-9]+)") <- Create Regex
  val matchGroups = regex01
      .matchEntire("ABcD..")?
      .groupValues
  while (matchGroups.find())
      println(matchGroups.group())
[[}]]

● KOTLIN: AVOIDING NULLS  [[{qa.billion_dolar_mistake]]
@[https://kotlinlang.org/docs/reference/null-safety.html]
  val nullable01 : String? = "abc"     <- nullables must be declared explicetelly with <Type>?

  val s02 : String =                   <- Assigning nullable to non-nullable
     if (nullable01 != null)              requires if (..!=null) ... else ...
         b.length
     else -1
  val l = b?.length ?: -1              <- "Shortcut" / Syntax-sugar Using "Elvis operator" ?:

  val name = node.getName()!!          <- Abort and throw NullPointerException if null present


  nullableInstance ?                   <- Null check "shortcut"/"Syntax sugar".
     .department ?                        Returns null if nullableInstance, department
        .data ?                            or data is null

  val listWithNulls:
     List<String?> = listOf("A", null)
  for (item in listWithNulls) {
    item ?.let  { println(it) }        <- "?.let" skips block if item instance is null
       block execution for nulls */*
  }

  val intList: List<Int> =
    listOf(1, 2, null, 4)
     .filterNotNull()                  <- Fix/Remove Nulls at list initialization.

  fun getName(): String? = ...         <-  SmartCast
  val name = getName()
  if (name != null) {
    println(name.length)               <-  Here compiler knows that 'name' is not null
  }
[[qa.billion_dolar_mistake}]]

 obj: Any = 1
 String = when(obj) {                  ● 'when' extended switch-case
   1            -> "One"
   "Hello"      -> "Greeting"
   is Long      -> "Long"
   in 32..128   -> "Is ASCII"
   !is String   -> "Not a string"
   "dog" in obj -> "Animal list"
   else         -> "Unknown"
 }

● Strings 101 [[{strings]]

  val s1 = "Hello World  $A !"       <- String template
  "col1:  ${ s1.replace("A", "B") } $d"
          └┴──────────────────────┴─ <- String Expresions

  val myMultiLineString = """        <- Multiline string with margin
     |  for (c in "foo")
     |      print(c)
     |  Dolar is writen as ${'$'}
  """. trimMargin()                  <- remove leading spaces.

  val s1 = charArrayOf('a','b')      <- array to string.
           .asSequence()
           .joinToString(",")
[[strings}]]

● INTERFACES [[{interfaces]]
  interface Iface1<out T : Any> {            INTERFACE DEFINITION
      val prop1: Int                 <- Properties can be part of the interface.
      val prop2: String
           get() = "foo"             ← default accessor
      fun bar(): T
      fun foo(): Unit
      fun foo(a: Int): T                                 ← instance: => instance ←→ type
  }



  class Class : Iface1, Iface2 {    <- Declare class as implemeting interfaces' contracts
    override val prop: Int = 29
  }

• SINGLE-METHOD-INTERFACE PATTERN (Similar to that use in GO and other modern languages)
  (Runnable, Callable, Closeable, Comparator, ...)
  val threadPool = Executors.newFixedThreadPool(4)

  "Real" Code:                  Shortcut "Syntax-Sugar"
  ======================        =======================
  threadPool.submit(            threadPool.submit { <···┐
    object : Runnable {           println("...")        ·
     override fun run() {       }                       ·
       println("...")           ┌······················─┘
     }                          Compilers infers that { ... }
    }                           implements the expected fun run()
  )                             in  <<Runnable>>>
[[interfaces}]]

● KOTLIN FUNCTIONS   [[{functions]]
@[https://kotlinlang.org/docs/reference/functions.html]
        (Int) -> String       <··· function type signature:
                                   Input  is Int, Output is String
  TypeA.(Int) -> String       <··· function-with-receiver type signature
                                   Input  is Int, Output is String
                                   - Restriction: It must be called
                                     within the "context" of a receiver
                                     object TypeA (implicit .this in
                                     function body)

  val fun1:                   <··· type ((A, B) -> C) and
   String.(Int) -> String = ...    type ( A.(B) -> C) are compatible types
  val fun2:
  (String, Int) -> String = fun1     <- OK: Allowed assignement.

  suspend   () -> Unit       <··· 'suspend' (vs fun): set as corutine
  suspend A.(B) -> C.        <··· 'suspend' corutine with receiver type

  (x: Int, y: Int) -> Point  <··· 'x','y' names for parameters is Optional

  ((Int) -> Any)?            <··· '?' sets function-type as nullable.

  (Int) -> ((Int) -> Unit)   <··· function-type signature returns function-type

  typealias ClickHandler =   <··· Type alias for function signature.
     (Button, ClickEvent) -> Unit

  { a, b -> a + b }          <··· lambda expression, declares and init anonymous func.

  fun(s: String): Int {      <··· anonymous fun., useful when we need to explitely
    return s.toIntOrNull() ?: 0   define the return-type.
  }

  NOTE: 'return' inside lambdas        will return from the enclosing function.
        'return' inside anonymous fun. will return from the anonymous function itself.
                 Use 'return@enclosingFunction' to replicate lambda behaviour.
         fun foo() {
           ints.forEach lit@ {            <- Alt 1. lambda function
             if (it == 0) return          // returns from foo
             if (it == 1) return@lit      // returns from lambda lit@
             if (it == 2) return@forEach  // returns from lambda lit@ (implicit label)
             print(it)
           }
           ints.forEach( fun(val: Int) {  <- Alt 2. anonymous function
             if (it == 0) return          // local returns from  anonymous funct
             print(val)
           }
         }

  funA(x)   is equivalent to funA.invoke(x)   for non receiver function-types.
  O.funA(x) is equivalent to funA.invoke(O,x) for     receiver function-types

  items.fold(1, { lambda } ) <··· "traling lambda" Kotlin (syntax-sugar) convention:
  items.fold(1) { ... }           if last (or only) arg of function is a function-type,
                                  the lambda expression passed-as-argument can be
                                  placed outside the parentheses in order to allow
                                  replacing
                                  a ({ b ({ c }) })  by
                                  a  { b  { c }  }

  fun getPoint(                  <····· Alt 1: Fun. Def, java-like
      a: Int,
      b: Int  = 1                    <- Default values in functions [[qa.billion_dolar_mistake]]
      vararg names: String           <- variable-number-of-args supported (0 or more)
     )
  : Coordinate {                     <- Return type
    return Coordinate(a+b,a-b)
  }

  fun getPoint(                  <····· Alt 2: Fun. Def. Kotlin shorcut.
    Int, Int = 1, vararg: String)       <- param names not required.
      = Coordinate(a+b,a-b)             <- return type inferred

  val (x, y) = getPoint(1,2)         <- split returned value
  getPoint(a = 1, b = 2)             <- Using named parameters supported

  fun <T> singletonList(item: T):    <- Generic Functions
    List<T> {                           <T> is specified before the fun. name
      ...
  }

• tailrec   <·························· 'tailrec' tells compiler that implementation [[{performance]]
  fun findFixPoint(x: Double = 1.0)     must be tail-recursive. Otherwise compilation must fail.
  :Double                               Compiler optimises out the recursion!!!
    = if (x == Math.cos(x)) x
      else findFixPoint(Math.cos(x)) <· recursive call must be last operation.
           └··········┘                 WARN : doesn't work within try/catch.
                                        only supported in JVM as of 2018?? ([[01_PM.TODO:Update as 202?) [[}]]

· inline fun lock(x1: Class1) :      <- Inline fun. definition.
    ReturnClass { ... }

· fun String.spaceToCamelCase()      <- (Class) EXTENSION FUNCTIONS: provides shorted systax
      String { ... }                    for the "friend" class objects (String in this case)
  "to camelcase".spaceToCamelCase()     <- OK
  23424.spaceToCammelCase()             <- Compiler error. Doesn't match expected class.

· val countChars: String.() -> Unit =   <- Fun. as value object. Type is 'String.() -> Unit'
      { println("${length}") }             <- Value is the executable code defined in {} block
  "ASDF".countChars( )                  <- Ussage Allowed ( or countChars( "ASDF" ) )

· FUNCTION RECEIVERS: Very similar to extension functions but applies to
  func. literals. (that is, to variables representing functions)

           ┌──┬─························· receiver Object members can be
  val sum: Int.(other: Int) -> Int = {    accessed with an implicit 'this.'
   other -> plus(other)                ┌· == this.plus, where 'this' is the
  }         └──┴─······················┘  receiver.
                                          == other -> other.plus(this)

· class Account {
    var balance = 0.0                      INFIX Functions (DSL utility)
    infix fun add(amount:Double): Unit  <- 'infix' declaration for function
          : Unit {
       this.balance = balance + amount
    }
  }
  accountInstance add 100.00            <- Infix ussage


· OPERATOR    FUNCTION NAME              OPERATOR OVERLOADING
  ========    =============              Allowed for well defined set of operators
  a + b     : plus      ()               (vs "anything" in C++)
  a - b     : minus     ()
  A * b     : times     ()
  A / b     : div       ()
  A & b     : mod       ()
  a..b      : rangeTo   ()
  +a        : unaryPlus ()
  -a        : unaryMinus()
  !a        : not       ()
  [p1,p2,..]: operator fun get(param1, param2,...)
  < <=  > >=: compareTo ()
  ()        : operator func invoke()

· fun foo(                            <-● HIGH ORDER FUNCTION
       name: String,
       fun1: (String) -> String)           <- receives another fun. as param.
       : Unit {
    val applied = fun1(name)
    println(applied)
  }
  foo(name = "hello",
      fun1 = { it.reversed() } )        <- Ussage

• fun students(nameToMatch: String)
      : List<Student> {
    return loadStudents().filter {    <-●  CLOSURE function with access to
      it.lastName == nameToMatch           parent stack
    }
  }

· fun Function1 .memoized()           <-● MEMOIZATION  [[{performance.101]]
      : (String) -> MyClass {
                                           (Avoid repeated long-running calculus)
    val map = ConcurrentHashMap<String, MyClass>()
    return {
      a -> map.getOrPut(a) {
        this.invoke(a)
      }
    }
  }                                       [[}]]
[[functions}]]

● Kotlin OOP [[{oop]]
• Kotlin Classes:
@[https://kotlinlang.org/docs/reference/classes.html]
- 'Any' : common superclass in Kotlin.
- It is NOT java.lang.Object;
  it does not have any members other than
  equals(), hashCode() and toString().

- By default classses are final.  [[qa.101,qa.immutability]]
  Use syntax 'open class ...' to make them non-final

● COMPOSITION OVER INHERITANCE [[{oop.composition,qa.best_patterns]]
  Sometimes called delegation, where delegation is actually the dessign pattern
  and composition the standard/easiest way to implement it.
  - Inheritance means that child *IS A* parent. This claim fails to be true
    frequently in business applications. Problems that can arise:
      Initially a 'worker' can be a physical/legal person and so we claim
    that worker 'IS A' person.  Two years later a 'worker' is a robot, and
    our initial hierchy breaks forcing lot of refactoring (or "patching" our
    initial model considering that robots are persons with "empty name", ...)
      It's much worse when we want to upgrade the base clase with behaviour that
    children classes were not expected to implement.
      E.g.: Now legal person is being used by the legal department and they
    require a physical address for persons, but 'workers' were used by a
    Resource/Scheduling Planning application with no need for this physical address
    and now is receiving extra information that the software does not understand
    or breaks serialization/JSON parsing/...

  - REF1: "Efective Java"
  - REF2: "https://kotlinlang.org/docs/reference/delegation.html"

  - Note: foreign keys in SQL is the best well known form of composition:

    employee      person     client         <- employee and client just keep
    --------      -------    ------            pointers (foreign keys) to
    id      ←─┐┌─→ id   ←─┐  id                persons.
    roll      ││   name   └─ fk_person
    fk_person ─┘   ...    ┌─ fk_saleManager
    ...       └───────────┘   ...

    With composition a worker is not a person but is composed with a person.
    worker01.person is defined.
    robot_01.person is null or event better, points to mock 'person'.
    person data can be loaded lazely, on demand, increasing performance.
    If parent Person add a physical address Worker is not aware of it,
    it just keep a pointer.

· Example Composition Implementation in Kotlin:
  interface IPerson { fun print() ... }

  class Person(val name: String, ...)
    : IPerson {
    override fun print() { print(x) }
  }

  class Employee(p: IPerson, ...)        "Employee" implements" Person behaviour
        : IPerson  by  b              <- by passing through its p member.

  fun main(args: Array<String>) {
    valA person01 = Person(name: "...",... )
    val employee = Employee(
                     person: person01,
                     roll: manager,
                     ... )
    employee.print()                  <- "Shortcut" for employee.person.print()
  }
[[oop.composition}]]

• OOP Inheritance  [[{oop.inheritance]]

  - discouraged pattern except when we can formally probe (after
    publishing in a Journal-of-Mathematic paper) that child class
    IS ACTUALLY a base class.
    - 'group', 'monoid', 'ring' are always a 'set' BY DEFINITION.
    - 'triangle', 'square', .. are always a 'closed 2D shape'.
      (but a physical triangle will soon stop being a 2D shape,
       even if some 2D closed shape still apply. In that case use
       delegation through composition).

  class Derived(p: Int)   :  Base(p)    <- Inheritance declaration

  class Container(
    id     : Int,
    size   : Int,
    childs : Containers
  ) : SuperClass(id, name),             <- Child class inheriting from SuperClass
    Iface1, Iface2, Iface3 {               and implementing orthogonal (Unrelated)
    var person_id = id                     interfaces.
    val isEmpty: Boolean
        get() = this.size == 0 ||       <- Custom (get) accesor.
               (var sum = 0; for (c in childs) sum+=c.size) == 0
    val stringRepr : String
         get() = this.toString()
         set(value) = _setFromString(value)
    // ...

     companion object Factory
               : FactoryTemplate<MyClass> { // ← object name ('Factory') can be ommited
      override fun create(): Container = Container(...)
    }
    val instance = MyClass.create()
  }
[[oop.inheritance}]]

                           ● SINGLETON OBJECTS  [[{oop.singleton,qa.101]]
  object  Resource {         <- use 'object' instead of 'class'
    val name = "Name"
    fun method1(...) { ... }
    ...
  }
  Resource.method1(...)   [[oop.singleton}]]

                          ● COMPANION OJECTS ("static" methods in Java)
  class Class1 {
    companion object Fact01      <·· Companion object. 'Fact01' name can be omitted *1
       : IFactory<Class1> {      <·· the companion object can (at will) implement an interface
                                     (this is not possible with static methods in Java)
      override fun create(): ...     Use @JvmStatic annotation for compatibility with Java
    }                                *1: It can still be referenced with Class1.Companion
  }
  val instance = Class1.create() <·· In can be now used as an "static" method.

● COMPAQ CLASS DECLARATION [[{]]
  class Person(
    val firstName: String,   <- val/var in constructor define also members
    val lastName: String,
    var age: Int) {
    ...
  }

  class Customer
    public
    @Inject
    constructor ( val name: String = "")  <- 'constructor'  keyword optional if no
  {                                          annotations and default visibility applies
      ...
      init {                              <- 'init' marks an initializer block
        logger.info("init ${name}")
      }
      constructor(parent: Person) {       <-  "Secondary" constructor
        parent.children.add(this)
    }
  }
[[}]]

● SEALED CLASS  [[{oop.sealed_class]]
@[https://kotlinlang.org/docs/reference/sealed-classes.html]
- represent restricted class hierarchies or "sort of" enum extensions,
  with subclasses being able to have multiple instances.
- (sealed class/subclasses must be declared in the same file)

  sealed class Expr         <························ 'sealed' declares 'Expr' as sealed.
  data class Const(val number: Double)       : Expr()
  data class Sum(val e1: Expr, val e2: Expr) : Expr()
  object /*singleton*/ NotANumber            : Expr()

  fun eval(expr:  Expr ): Double =                   <··· Ussage:
    when(expr) {
    is  Const       -> expr.number
    is  Sum         -> eval(expr.e1) + eval(expr.e2)
        NotANumber  -> Double.NaN
  }
[[oop.sealed_class}]]

● INNER CLASS [[{oop.inner_class]]
  window.addMouseListener(
      object : ListenerBase (            <······ Example 1.  Object expressions are a
      baseClassConstructorParam1,                generalization of anonymous inner classes:
      ...) {
        override fun
          onMouseClicked(e: MouseEvent)
            { ... }
      })

  interface B {...}                      <······ Example 2. [[{01_PM.TODO]]
  val ab: A = object : A(1),
              B { override ...  }                 [[}]]
[[oop.inner_class}]]
[[oop}]]

● 'atomic' concurrent code: [[{concurrent.101]]
  STM: Software transactional memory
  Extracted from https://blog.plan99.net/kotlin-fp-3bf63a17d64a
  JVM can support libraries like Scala STM and something better:
  "...Modern (very modern as of 2015) Intel chips support 'TSX'
  instructions to create an hardware atomic TX, controlling cache
  lines accessed by different cores simultaneously.
   In case of conflict, the CPU aborts the TX and expects the code to
  try again or fall back to regular locking.
    Java 8 Update 40, the "RTM locking" is enabled by default when the
  CPU supports it converting every Java synchronized block into a
  hardware level atomic transaction using TSX.
  NOTE: STMs often provide extra features, like the
        ability to pause/retry a code block when the
        dependencies change, or the ability to explicitly
        cancel a TX (by throwing) without retrying it.

   val accounts = intArrayOf(10,..) <··· our critical structure
   try {
     atomic {                  <··· higher order function protected by Java 'synchronized'.
       accounts[from] -= amount     immediately calling the provided code block. The JVM will ignore the
       accounts[to] += amount       lock on TSX-enabled hardware with all threads running in parallel
       if (...) throw ...           As long as two threads are using different account IDs for 'from'/'to'
     }                              no locking is done at all.
   } catch(e: Exception) {
       println("counter is ${counter.get()}")        // -> 10
   }


  - Things Kotlin lacks (As of 2015)
    - no way to control side effects for non const (val) variables.
      or external inputs/outputs.
   - lack of a high performance immutable collections library.
     Both Clojure and Scala have maps and sets in which mutating the
     collection returns a new collection, with internal data sharing
     to make performance practical.
[[concurrent.101}]]
[[101}]]

● Kotlin declaration-site variance: [[{generics]]
  Read https://kotlinlang.org/docs/generics.html for more detailed info.
                                        Source is covariant in O, contravariant in I.
   interface Source<out O, in I> { <··· O is only returned (produced), never take as input param.
                                        I is only taken as input (consumed) param, never returned.
       fun nextT(): O              <··· out O may occur only in the out-position in the members of C
       fun compareTo(other: T): Int<··· in  I may occur only in input-position params.
   }


  class Array<T>(val size: Int) {           <··· T now is an in and out. neither co/contra-variant
      operator fun get(index: Int): T { ... }
      operator fun set(index: Int, value: T) { ... }
  }

  fun copy(from: Array<Any>, to: Array<Any>)     <··· Will fail
  fun copy(from: Array<out Any>, to: Array<Any>) <··· Will work, this is call "TYPE PROJECTION"

  Type projection: "It is not a simple array, but is rather a restricted (projected) one"

  Foo<out T : TUpper> <··· T is covariant type "up to" TUpper.
  fun <T : Comparable<T>> sort(list: List<T>) {  ... }

  if (something is List<*>) <··· '*' needed to check for types.
[[generics}]]



● Kotlin Domain Specific Language (DSL) [[{dsl]]
  · REFs:
    https://blog.jetbrains.com/kotlin/2011/10/dsls-in-kotlin-part-1-whats-in-the-toolbox-builders/
    https://kotlinlang.org/docs/reference/type-safe-builders.html
  · Examples
    https://github.com/Kotlin/anko/wiki/Anko-Layouts   (Programatically generate layouts)
    https://ktor.io/features/routing.html#routing-tree (Defining REST-API routing trees)

  JAVA-LIKE Code                        Kotlin DSL  equivatent
  Collection.sort( list );               list .sort();
  int index = Collection                 int index = list .binarySearch(x);
              .binarySearch( list ,x);   └─────┬─────────────────────────┘
  ┌············································┘
  PRESETUP:

  fun <T : Comparable<T>>  List<T>. sort() {  <··· Restrict fun <T : Comparable<T>> sort()
     Collections.sort(this)                        to List<T> elements
  }                                                (i.e., only to elements compatibles with
                                                    Collections.sort )


  JAVA-LIKE Code:               | DSL using infix functions
  ---------------------------   | ------------------------        human friendly "subject"
  hasPrivilege (  it , WRITE)   | it   hasPrivilege  WRITE  <···  + verb + "predicate"

                                |                                 last function literal can be
  lock(myLock,   {...} )        | lock(myLock),   {...}     <···  put outside the parenthesis

                                |                                 Convention:
                                |                                 If function has a single input param,
                                |                                 its declaration may be omitted,
  filter { it => it.foo()}      |filter { it.foo() }        <···  default "it" name used.


• Example Kotlin DSL for Type-safe HTML builder:
  (See @[https://kotlinlang.org/docs/type-safe-builders.html] and
       @[https://github.com/Kotlin/kotlinx.html] for more elaborate example code)

  Code Summary -----------------
  class HTML {                      <··· STEP 1: Receiver class
      fun body() ...
  }

  fun funHtml(                        <··· STEP 2: funHtml builder taking as input
        initLambda:  HTML.() -> Unit           any arbitrary lamda matching the
      )  //          └─────────────┴─········· function-with-receiver signature declaration
      : HTML {
      val html = HTML()  // <··· create the receiver object
      html.initLambda()  // <···  pass the receiver object to the lambda
      return html
  }

  funHtml                            <···· STEP 3: Use it by invoking the 'builder
  {                                        with an arbitrary lambda function compatible
      body()       == this.body(           with the signature.
  }


[[dsl}]]

● kotlinx.serialization: marshal objects using JSON or ProtoBuf. [[{IO.serialization,JSON,]]
  https://github.com/kotlin/kotlinx.serialization

  import kotlinx.serialization.*
  import kotlinx.serialization.json.*

  @Serializable
  data class DProject(val name: String, val language: String)

  val data1  = DProject("kotlinx", "Kotlin")
  val strn1 = Json.encodeToString(data)    <··· Object -> JSON-string
  val data2 = Json                         <··· Object <- JSON-string
              .decodeFromString<DProject>(strn1)
[[}]]

● 'gradle.properties' to customize Kotlin settings:  [[{devops.gradle]]
  REF: https://kotlinlang.org/docs/reference/using-gradle.html
  kotlin.code.style=official
  kotlin.caching.enabled=true
  kotlin.incremental=true
  kotlin.incremental.js=true

  kapt.use.worker.api=true     <··· REF:
  kapt.incremental.apt=true         https://kotlinlang.org/docs/reference/kapt.html
[[devops.gradle}]]

● Coroutines  [[{coroutines,02_doc_has.comparative,performance]]
- experimental starting with v.1.1+
- Basically, coroutines are computations that can be suspended without blocking
  a thread.
- Suspension can be controlled by a user library to a large extent deciding
  what happens upon suspension and optimize/log/intercept according to our needs.

- Compared to threads, coroutines can not be suspended at random instructions,
  but rather only at defined suspension points, which are calls to specially
  marked functions.

  suspend fun  susA(foo: Foo)    <·· 'suspend' marks the function as a suspension point
               : Bar {               funA can ONLY be called from coroutines and other
    ...                              suspending functions
  }

- To start a coroutine, there must be at least one suspending function,
    and it is usually a suspending lambda. Ex:

             ┌·····················  async is a regular function
             │                    ┌ lambda suspendable funct
           ┌─┴─┐             ┌────┴───────┐
   fun <T> async(  block :  suspend () -> T)

   Suspendable functions USSAGE rules:
   - suspending functions canNOT be called from function literals that
     are NOT inlined into a suspending function body and from regular
     function like main():

   fun main(args: Array<String>) {
     susA()                         <·· ERROR: Can NOT be called from a non-coroutine context
     async {
       susA(foo)                    <·· OK:  We can now call the suspendable function susA
       ...
       val result =                     await() can be a suspending function
          computation.await()       <·· suspending the coroutine until some
                                        computation is done and returns its
       ...
       computationsO .forEach {     <·· lambda is inlined.
           it.await()               <·· OK!! Async. blocking calls can now
       }                                be expressed sequentially
     }

     async {
       thread {
         susA()                    <·· ERROR, `thread` is not an inline function
       }                               so the lambda is not inlined
     }
   }

   @RestrictsSuspension            <·· prevent users from adding new ways of suspending a coroutine
   public abstract class              all suspending extensions are required to delegate to
      SequenceBuilder<in T> {         members of class or class-extensions avoid third extensions
       ...                            to delegate on each other indefinitely and forcing all
   }                                  suspensions to be controlled by members of the class.
                                      controlled by the author of the library.

  ┌ [[{02_doc_has.KEY-POINT]] ─────────────────────────────────────────┐
  │ the underlying library will transparently hide all the complexity  │
  │ of wrapping callbacks, subscribing to relevant events, scheduling  │
  │ execution on different threads (or even different machines!)       │
  │                                                                    │
  │ It can be used to implement async mechanisms like async/await in   │
  │ C#/ECMAScript, channels/select in Go, generators/yield in C#/Python│
  └─^──────────────────────────────────────────────────────────────[[}]]
    inner workings:
    - Coroutines are completely implemented through a compilation technique
      (NO SUPPORT FROM THE VM OR OS SIDE IS REQUIRED), and suspension
      works through code transformation.
     ┌ [[{02_doc_has.KEY-POINT]] ──────────────────────────────────────────────┐
     │ Briefly, every suspending function is transformed to a state machine    │
     │ where states correspond to suspending calls. Right before a suspension, │
     │ the next state is stored in a field of a compiler─generated class       │
     │ along with relevant local variables, etc.                               │
     │ Upon resumption of that coroutine, local variables are restored and the │
     │ state machine proceeds from the state right after suspension.           │
     └─────────────────────────────────────────────────────────────────────[[}]]
    - A suspended coroutine can be stored and passed around as an object
     that keeps its suspended state and locals. The type of such objects is
     Continuation, and the overall code transformation described here corresponds to
     the classical Continuation-passing style. Consequently, suspending functions
     take an extra parameter of type Continuation under the hood.

- See also Design documents and examples for coroutines in Kotlin
@[https://github.com/Kotlin/kotlin-coroutines]
@[https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md#composing-suspending-functions]

• kotlinx.coroutines [[{01_PM.TODO]]
@[https://kotlinlang.org/docs/reference/coroutines.html]
@[https://github.com/Kotlin/kotlinx.coroutines/blob/master/coroutines-guide.md]
  This repo mostly consists of core primitives and interfaces that all coroutine-based
  libraries are likely to use covering:
  - Platform-agnostic asynchronous programming with kotlinx-coroutines-core,
    including Go-like channels that support select and other convenient
    primitives.
  - APIs based on CompletableFuture from JDK 8: kotlinx-coroutines-jdk8
  - Non-blocking IO (NIO) based on APIs from JDK 7 and higher:
    kotlinx-coroutines-nio
  - Support for Swing (kotlinx-coroutines-swing) and JavaFx
    (kotlinx-coroutines-javafx)
  - Support for RxJava: kotlinx-coroutines-rx [[}]]
[[coroutines}]]

● kscript (Kotlin as script lang)  [[{qa.UX,01_PM.TODO.now]]
@[https://github.com/holgerbrandl/kscript]
  See also
@[https://holgerbrandl.github.io/kscript_kotlinconf_2017/kscript_kotlinconf.html#1]
  - Compiled script caching (using md5 checksums).
  - Dependency declarations using gradle-style resource locators and
    automatic dependency resolution with maven
  - More options to provide scripts including interpreter mode,
    reading from stdin, local files or URLs
  - Embedded configuration for Kotlin runtime options
  - Support library to ease the writing of Kotlin scriptlets
  - Deploy scripts as stand-alone binaries
[[qa.UX}]]

NON CLASSIFIED NOTES [[{01_PM.TODO.non_classified]]
● kotlin.test: (out of the box in Kotlin 1.2+)
  http://kotlinlang.org/api/latest/kotlin.test/index.html
  write test once under JVM and JS.

● https://github.com/kotlin/kotlinx.html
  - supports ISOMORPHIC RENDERING, using the same code to
    render HTML in the backend and in the frontend;

● https://medium.com/blockchain-engineering/kotlin-akka-part-1-hello-kotlin-a0c0de7d7407

● https://es.slideshare.net/IldarNurgaliev/kotlin-compiler-construction-very-brief

● https://blog.jetbrains.com/kotlin/2018/09/kotlin-1-3-rc-is-here-migrate-your-coroutines
● https://blog.jetbrains.com/kotlin/2017/12/kotlinnative-v0-5-released-calling-kotlin-from-swift-and-c-llvm-5-and-more/
  Kotlin/Native v0.5 released: calling Kotlin from Swift and C, LLVM 5 and more
● https://developers.redhat.com/blog/2018/12/24/using-a-kotlin-based-grpc-api-with-envoy-proxy-for-server-side-load-balancing/
● https://javalin.io [[{IO.http.javalin,qa.UX,qa.documentation,01_PM.low_code]]
  - Javalin support OpenAPI (including Swagger UI and ReDoc).
  - Built on top of Jetty.
  - 7k lines of code, 10k lines of tests!!!
  - No need to extend classes and rarely need for new interfaces.
  - Used by Johns Hopkins Institute, Microsoft, Red Hat, Norwegian University of Science and Techology,
    Uber, Deutsche Kredibank AG, C6BANK, ...
  - Web Sockets supports
  - ┌─ example.kt ──────────────────────────────────────────
    │ // Deps: implementation "io.javalin:javalin:5.3.1"
    │ import io.javalin.Javalin;
    │ import io.javalin.apibuilder.ApiBuilder.*;
    │
    │ val app = Javalin.create { config ->
    │     config.enableCorsForAllOrigins()
    │     config.asyncRequestTimeout = 10_000L
    │     config.enforceSsl = true
    │ }.routes {
    │     path("users") {
    │         get(UserController::getAll)
    │         post(UserController::create)
    │         path("{userId}") {
    │             get(UserController::getOne)
    │             patch(UserController::update)
    │             delete(UserController::delete)
    │         }
    │         ws("events", userController::webSocketEvents)
    │     }
    │ }.start(port)
    └───────────────────────────────────────────────────────
  [[IO.http.javalin}]]
● https://www.infoq.com/articles/kotlin-multiplatform-ios-developers/
  Kotlin Multiplatform for iOS Developers
    Using Kotlin Multiplatform, you can avoid repeating lots of logic
  to develop an app running on multiple platforms.
    KMP is not the final step to accomplishing 100% shared code across
  all platforms since UI logic must still be programmed natively in
  many cases because it is too platform-specific to share.
    The close similarities between Swift's and Kotlin's syntax greatly
  reduces a massive part of the learning curve involved with writing
  that KMP business logic.
    You can use Android Studio to create a reusable KMP component that
  you later import into an Xcode project as a framework.

● https://allegro.tech/2018/05/From-Java-to-Kotlin-and-Back-Again.html

● https://kotlinlang.org/docs/reference/sequences.html
  long with collections, the Kotlin standard library contains another container type – sequences (Sequence<T>). Sequences offer the same functions as Iterable but implement another approach to multi-step collection processing.

When the processing of an Iterable includes multiple steps, they are executed eagerly: each processing step completes and returns its result – an intermediate collection. The following step executes on this collection. In turn, multi-step processing of sequences is executed lazily when possible: actual computing happens only when the result of the whole processing chain is requested.

The order of operations execution is different as well: Sequence performs all the processing steps one-by-one for every single element. In turn, Iterable completes each step for the whole collection and then proceeds to the next step.

So, the sequences let you avoid building results of intermediate steps, therefore improving the performance of the whole collection processing chain. However, the lazy nature of sequences adds some overhead which may be significant when processing smaller collections or doing simpler computations. Hence, you should consider both Sequence and Iterable and decide which one is better for your case.

● https://www.infoq.com/articles/kotlin-coroutines-bottom-up
Key Takeaways
- The JVM does not provide native support for coroutines
- Kotlin implements coroutines in the compiler via transformation to a state machine
- Kotlin uses a single keyword for the implementation, the rest is done in libraries
- Kotlin uses Continuation Passing Style (CPS) to implement coroutines
- Coroutines use Dispatchers, so are used slightly differently in JavaFX, Android, Swing, etc

● Google Protocol Buffers Support Idiomatic Kotlin Bindings [[{IO.grpc]]
  https://www.infoq.com/news/2021/12/protocol-buffers-kotlin-dsl/
[[}]]

● https://www.infoworld.com/article/3236419/development-tools/kotlin-frameworks-a-survey-of-jvm-development-tools.html#tk.ifw-infsb
  Kotlin Frameworks survey

● org.jetbrains.kotlin artifacts at Maven Central:
  https://search.maven.org/#search%7Cga%7C3%7Corg.jetbrains.kotlin

● Annotation Processing with kapt plugin (Use Dagger,... in Kotlin)
  https://kotlinlang.org/docs/reference/kapt.html
  Annotation processors (see JSR 269) are supported in Kotlin with the kapt
  compiler plugin. Being short, you can use libraries such as Dagger or Data
  Binding in your Kotlin projects.

● Kotlin: Android Developers Blog: Accelerated Kotlin build times with Kotlin Symbol Processing 1.0
  https://android-developers.googleblog.com/2021/09/accelerated-kotlin-build-times-with.html?m=1

● public class MyTest {
    lateinit var subject: TestSubject        <··· lateinit: non-null property that can NOT be initialized in constructor
                                                  (init through dependency injection framework ,...)
    @SetUp fun setup() {                          but we still want to avoid null checks. If property has not
        subject = TestSubject()                   custom getters/setters we can use it as non-null anywhere except in
    }                                             constructor.
                                                  Accessing it before init. throws an special exception
    @Test fun test() {                            that clearly identifies the issue.
        subject.method()  // dereference directly
    }
}

[[01_PM.TODO.non_classified}]]
[[kotlin}]]
